"use strict";(globalThis.webpackChunkairpath_docs=globalThis.webpackChunkairpath_docs||[]).push([[156],{1007:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>t,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"api-reference/pathfinding-service","title":"PathfindingService","description":"The PathfindingService is the core pathfinding engine. It handles grid initialization, A* path calculation, and coordinate conversions. While most users interact with PathfindingManager, you can use PathfindingService directly for custom implementations.","source":"@site/docs/api-reference/pathfinding-service.md","sourceDirName":"api-reference","slug":"/api-reference/pathfinding-service","permalink":"/airpath-docs/docs/api-reference/pathfinding-service","draft":false,"unlisted":false,"editUrl":"https://github.com/maybebool/airpath-docs/tree/main/docs/api-reference/pathfinding-service.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1},"sidebar":"docsSidebar","previous":{"title":"API Reference","permalink":"/airpath-docs/docs/category/api-reference"},"next":{"title":"IHeightProvider Interface","permalink":"/airpath-docs/docs/api-reference/height-provider-interface"}}');var s=n(4848),d=n(8453);const t={sidebar_position:1},o="PathfindingService",l={},c=[{value:"Namespace",id:"namespace",level:2},{value:"Class Definition",id:"class-definition",level:2},{value:"Initialization",id:"initialization",level:2},{value:"Initialize",id:"initialize",level:3},{value:"Path Calculation",id:"path-calculation",level:2},{value:"CalculatePath (Grid Positions)",id:"calculatepath-grid-positions",level:3},{value:"CalculatePath (World Positions)",id:"calculatepath-world-positions",level:3},{value:"Coordinate Conversion",id:"coordinate-conversion",level:2},{value:"WorldToGridPosition",id:"worldtogridposition",level:3},{value:"WorldToGridPositionSafe",id:"worldtogridpositionsafe",level:3},{value:"GridToWorldPosition",id:"gridtoworldposition",level:3},{value:"Bounds Checking",id:"bounds-checking",level:2},{value:"IsValidGridPosition",id:"isvalidgridposition",level:3},{value:"ClampToValidGridPosition",id:"clamptovalidgridposition",level:3},{value:"GetBoundaryHandler",id:"getboundaryhandler",level:3},{value:"Inspector Properties",id:"inspector-properties",level:2},{value:"Performance Notes",id:"performance-notes",level:2},{value:"See Also",id:"see-also",level:2}];function a(e){const i={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,d.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(i.header,{children:(0,s.jsx)(i.h1,{id:"pathfindingservice",children:"PathfindingService"})}),"\n",(0,s.jsxs)(i.p,{children:["The ",(0,s.jsx)(i.code,{children:"PathfindingService"})," is the core pathfinding engine. It handles grid initialization, A* path calculation, and coordinate conversions. While most users interact with ",(0,s.jsx)(i.code,{children:"PathfindingManager"}),", you can use ",(0,s.jsx)(i.code,{children:"PathfindingService"})," directly for custom implementations."]}),"\n",(0,s.jsx)(i.h2,{id:"namespace",children:"Namespace"}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-csharp",children:"PlatypusIdeas.AirPath.Runtime.Core.Pathfinding\n"})}),"\n",(0,s.jsx)(i.h2,{id:"class-definition",children:"Class Definition"}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-csharp",children:"public class PathfindingService : MonoBehaviour\n"})}),"\n",(0,s.jsx)(i.h2,{id:"initialization",children:"Initialization"}),"\n",(0,s.jsx)(i.h3,{id:"initialize",children:"Initialize"}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-csharp",children:"public void Initialize(GridConfiguration config, IHeightProvider heightProvider)\n"})}),"\n",(0,s.jsx)(i.p,{children:"Initializes the pathfinding service with grid configuration and height data."}),"\n",(0,s.jsx)(i.p,{children:(0,s.jsx)(i.strong,{children:"Parameters:"})}),"\n",(0,s.jsxs)(i.table,{children:[(0,s.jsx)(i.thead,{children:(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.th,{children:"Parameter"}),(0,s.jsx)(i.th,{children:"Type"}),(0,s.jsx)(i.th,{children:"Description"})]})}),(0,s.jsxs)(i.tbody,{children:[(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:(0,s.jsx)(i.code,{children:"config"})}),(0,s.jsx)(i.td,{children:(0,s.jsx)(i.code,{children:"GridConfiguration"})}),(0,s.jsx)(i.td,{children:"Grid settings (size, cell size, origin, cost multiplier)"})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:(0,s.jsx)(i.code,{children:"heightProvider"})}),(0,s.jsx)(i.td,{children:(0,s.jsx)(i.code,{children:"IHeightProvider"})}),(0,s.jsx)(i.td,{children:"Source of terrain height data"})]})]})]}),"\n",(0,s.jsx)(i.p,{children:(0,s.jsx)(i.strong,{children:"Example:"})}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-csharp",children:"using PlatypusIdeas.AirPath.Runtime.Core.Grid;\r\nusing PlatypusIdeas.AirPath.Runtime.Core.Pathfinding;\r\nusing PlatypusIdeas.AirPath.Runtime.Core.Terrain;\r\nusing UnityEngine;\r\n\r\npublic class PathfindingSetup : MonoBehaviour\r\n{\r\n    [SerializeField] private TerrainHeightProvider heightProvider;\r\n    \r\n    private PathfindingService _pathfindingService;\r\n    \r\n    void Start()\r\n    {\r\n        var config = new GridConfiguration(\r\n            width: heightProvider.GridWidth,\r\n            height: heightProvider.GridHeight,\r\n            cellSize: heightProvider.CellSize,\r\n            origin: heightProvider.Origin,\r\n            flyCostMultiplier: 2.5f\r\n        );\r\n        \r\n        _pathfindingService = gameObject.AddComponent<PathfindingService>();\r\n        _pathfindingService.Initialize(config, heightProvider);\r\n    }\r\n}\n"})}),"\n",(0,s.jsx)(i.admonition,{type:"caution",children:(0,s.jsxs)(i.p,{children:[(0,s.jsx)(i.code,{children:"Initialize()"})," must be called before any other methods. Calling ",(0,s.jsx)(i.code,{children:"CalculatePath()"})," without initialization returns ",(0,s.jsx)(i.code,{children:"null"}),"."]})}),"\n",(0,s.jsx)(i.h2,{id:"path-calculation",children:"Path Calculation"}),"\n",(0,s.jsx)(i.h3,{id:"calculatepath-grid-positions",children:"CalculatePath (Grid Positions)"}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-csharp",children:"public List<Vector3> CalculatePath(Vector2Int startPos, Vector2Int endPos, float heightOffset = 0)\n"})}),"\n",(0,s.jsx)(i.p,{children:"Calculates a path between two grid positions."}),"\n",(0,s.jsx)(i.p,{children:(0,s.jsx)(i.strong,{children:"Parameters:"})}),"\n",(0,s.jsxs)(i.table,{children:[(0,s.jsx)(i.thead,{children:(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.th,{children:"Parameter"}),(0,s.jsx)(i.th,{children:"Type"}),(0,s.jsx)(i.th,{children:"Description"})]})}),(0,s.jsxs)(i.tbody,{children:[(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:(0,s.jsx)(i.code,{children:"startPos"})}),(0,s.jsx)(i.td,{children:(0,s.jsx)(i.code,{children:"Vector2Int"})}),(0,s.jsx)(i.td,{children:"Start position in grid coordinates"})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:(0,s.jsx)(i.code,{children:"endPos"})}),(0,s.jsx)(i.td,{children:(0,s.jsx)(i.code,{children:"Vector2Int"})}),(0,s.jsx)(i.td,{children:"End position in grid coordinates"})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:(0,s.jsx)(i.code,{children:"heightOffset"})}),(0,s.jsx)(i.td,{children:(0,s.jsx)(i.code,{children:"float"})}),(0,s.jsx)(i.td,{children:"Height above terrain for path points (default: 0)"})]})]})]}),"\n",(0,s.jsxs)(i.p,{children:[(0,s.jsx)(i.strong,{children:"Returns:"})," ",(0,s.jsx)(i.code,{children:"List<Vector3>"})," of world positions forming the path, or ",(0,s.jsx)(i.code,{children:"null"})," if no path found."]}),"\n",(0,s.jsx)(i.p,{children:(0,s.jsx)(i.strong,{children:"Example:"})}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-csharp",children:'var path = _pathfindingService.CalculatePath(\r\n    startPos: new Vector2Int(10, 10),\r\n    endPos: new Vector2Int(50, 45),\r\n    heightOffset: 10f\r\n);\r\n\r\nif (path != null)\r\n{\r\n    Debug.Log($"Path found with {path.Count} waypoints");\r\n    foreach (var waypoint in path)\r\n    {\r\n        Debug.Log($"  \u2192 {waypoint}");\r\n    }\r\n}\r\nelse\r\n{\r\n    Debug.Log("No path found");\r\n}\n'})}),"\n",(0,s.jsx)(i.hr,{}),"\n",(0,s.jsx)(i.h3,{id:"calculatepath-world-positions",children:"CalculatePath (World Positions)"}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-csharp",children:"public List<Vector3> CalculatePath(Vector3 worldStart, Vector3 worldEnd, float heightOffset = 0)\n"})}),"\n",(0,s.jsx)(i.p,{children:"Calculates a path between two world positions. Automatically converts to grid coordinates."}),"\n",(0,s.jsx)(i.p,{children:(0,s.jsx)(i.strong,{children:"Parameters:"})}),"\n",(0,s.jsxs)(i.table,{children:[(0,s.jsx)(i.thead,{children:(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.th,{children:"Parameter"}),(0,s.jsx)(i.th,{children:"Type"}),(0,s.jsx)(i.th,{children:"Description"})]})}),(0,s.jsxs)(i.tbody,{children:[(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:(0,s.jsx)(i.code,{children:"worldStart"})}),(0,s.jsx)(i.td,{children:(0,s.jsx)(i.code,{children:"Vector3"})}),(0,s.jsx)(i.td,{children:"Start position in world space"})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:(0,s.jsx)(i.code,{children:"worldEnd"})}),(0,s.jsx)(i.td,{children:(0,s.jsx)(i.code,{children:"Vector3"})}),(0,s.jsx)(i.td,{children:"End position in world space"})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:(0,s.jsx)(i.code,{children:"heightOffset"})}),(0,s.jsx)(i.td,{children:(0,s.jsx)(i.code,{children:"float"})}),(0,s.jsx)(i.td,{children:"Height above terrain for path points (default: 0)"})]})]})]}),"\n",(0,s.jsxs)(i.p,{children:[(0,s.jsx)(i.strong,{children:"Returns:"})," ",(0,s.jsx)(i.code,{children:"List<Vector3>"})," of world positions forming the path, or ",(0,s.jsx)(i.code,{children:"null"})," if no path found."]}),"\n",(0,s.jsx)(i.p,{children:(0,s.jsx)(i.strong,{children:"Example:"})}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-csharp",children:"var agentPosition = transform.position;\r\nvar targetPosition = target.transform.position;\r\n\r\nvar path = _pathfindingService.CalculatePath(\r\n    worldStart: agentPosition,\r\n    worldEnd: targetPosition,\r\n    heightOffset: 15f  // Fly 15 units above terrain\r\n);\n"})}),"\n",(0,s.jsx)(i.admonition,{type:"tip",children:(0,s.jsx)(i.p,{children:"Use the world position overload when working with GameObjects. It handles coordinate conversion internally."})}),"\n",(0,s.jsx)(i.h2,{id:"coordinate-conversion",children:"Coordinate Conversion"}),"\n",(0,s.jsx)(i.h3,{id:"worldtogridposition",children:"WorldToGridPosition"}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-csharp",children:"public Vector2Int WorldToGridPosition(Vector3 worldPos)\n"})}),"\n",(0,s.jsxs)(i.p,{children:["Converts a world position to grid coordinates. If ",(0,s.jsx)(i.code,{children:"AutoClampOutOfBounds"})," is enabled, out-of-bounds positions are clamped to valid grid edges."]}),"\n",(0,s.jsx)(i.p,{children:(0,s.jsx)(i.strong,{children:"Parameters:"})}),"\n",(0,s.jsxs)(i.table,{children:[(0,s.jsx)(i.thead,{children:(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.th,{children:"Parameter"}),(0,s.jsx)(i.th,{children:"Type"}),(0,s.jsx)(i.th,{children:"Description"})]})}),(0,s.jsx)(i.tbody,{children:(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:(0,s.jsx)(i.code,{children:"worldPos"})}),(0,s.jsx)(i.td,{children:(0,s.jsx)(i.code,{children:"Vector3"})}),(0,s.jsx)(i.td,{children:"Position in world space"})]})})]}),"\n",(0,s.jsxs)(i.p,{children:[(0,s.jsx)(i.strong,{children:"Returns:"})," ",(0,s.jsx)(i.code,{children:"Vector2Int"})," grid position."]}),"\n",(0,s.jsx)(i.p,{children:(0,s.jsx)(i.strong,{children:"Example:"})}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-csharp",children:'var gridPos = _pathfindingService.WorldToGridPosition(transform.position);\r\nDebug.Log($"Agent is at grid cell ({gridPos.x}, {gridPos.y})");\n'})}),"\n",(0,s.jsx)(i.hr,{}),"\n",(0,s.jsx)(i.h3,{id:"worldtogridpositionsafe",children:"WorldToGridPositionSafe"}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-csharp",children:"public Vector2Int WorldToGridPositionSafe(Vector3 worldPos, out bool wasOutOfBounds)\n"})}),"\n",(0,s.jsx)(i.p,{children:"Converts a world position to grid coordinates with out-of-bounds detection."}),"\n",(0,s.jsx)(i.p,{children:(0,s.jsx)(i.strong,{children:"Parameters:"})}),"\n",(0,s.jsxs)(i.table,{children:[(0,s.jsx)(i.thead,{children:(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.th,{children:"Parameter"}),(0,s.jsx)(i.th,{children:"Type"}),(0,s.jsx)(i.th,{children:"Description"})]})}),(0,s.jsxs)(i.tbody,{children:[(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:(0,s.jsx)(i.code,{children:"worldPos"})}),(0,s.jsx)(i.td,{children:(0,s.jsx)(i.code,{children:"Vector3"})}),(0,s.jsx)(i.td,{children:"Position in world space"})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:(0,s.jsx)(i.code,{children:"wasOutOfBounds"})}),(0,s.jsx)(i.td,{children:(0,s.jsx)(i.code,{children:"out bool"})}),(0,s.jsxs)(i.td,{children:["Set to ",(0,s.jsx)(i.code,{children:"true"})," if position was outside grid bounds"]})]})]})]}),"\n",(0,s.jsxs)(i.p,{children:[(0,s.jsx)(i.strong,{children:"Returns:"})," ",(0,s.jsx)(i.code,{children:"Vector2Int"})," grid position (clamped if out of bounds)."]}),"\n",(0,s.jsx)(i.p,{children:(0,s.jsx)(i.strong,{children:"Example:"})}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-csharp",children:'var gridPos = _pathfindingService.WorldToGridPositionSafe(\r\n    target.position, \r\n    out bool wasOutOfBounds\r\n);\r\n\r\nif (wasOutOfBounds)\r\n{\r\n    Debug.LogWarning("Target is outside pathfinding grid!");\r\n}\n'})}),"\n",(0,s.jsx)(i.hr,{}),"\n",(0,s.jsx)(i.h3,{id:"gridtoworldposition",children:"GridToWorldPosition"}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-csharp",children:"public Vector3 GridToWorldPosition(Vector2Int gridPos, float yOffset = 0)\n"})}),"\n",(0,s.jsx)(i.p,{children:"Converts grid coordinates to a world position."}),"\n",(0,s.jsx)(i.p,{children:(0,s.jsx)(i.strong,{children:"Parameters:"})}),"\n",(0,s.jsxs)(i.table,{children:[(0,s.jsx)(i.thead,{children:(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.th,{children:"Parameter"}),(0,s.jsx)(i.th,{children:"Type"}),(0,s.jsx)(i.th,{children:"Description"})]})}),(0,s.jsxs)(i.tbody,{children:[(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:(0,s.jsx)(i.code,{children:"gridPos"})}),(0,s.jsx)(i.td,{children:(0,s.jsx)(i.code,{children:"Vector2Int"})}),(0,s.jsx)(i.td,{children:"Position in grid coordinates"})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:(0,s.jsx)(i.code,{children:"yOffset"})}),(0,s.jsx)(i.td,{children:(0,s.jsx)(i.code,{children:"float"})}),(0,s.jsx)(i.td,{children:"Height offset to add (default: 0)"})]})]})]}),"\n",(0,s.jsxs)(i.p,{children:[(0,s.jsx)(i.strong,{children:"Returns:"})," ",(0,s.jsx)(i.code,{children:"Vector3"})," world position."]}),"\n",(0,s.jsx)(i.p,{children:(0,s.jsx)(i.strong,{children:"Example:"})}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-csharp",children:'var gridPos = new Vector2Int(32, 32);\r\nvar worldPos = _pathfindingService.GridToWorldPosition(gridPos, yOffset: 10f);\r\nDebug.Log($"Grid center is at world position {worldPos}");\n'})}),"\n",(0,s.jsx)(i.h2,{id:"bounds-checking",children:"Bounds Checking"}),"\n",(0,s.jsx)(i.h3,{id:"isvalidgridposition",children:"IsValidGridPosition"}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-csharp",children:"public bool IsValidGridPosition(Vector2Int pos)\n"})}),"\n",(0,s.jsx)(i.p,{children:"Checks if a grid position is within valid bounds."}),"\n",(0,s.jsx)(i.p,{children:(0,s.jsx)(i.strong,{children:"Parameters:"})}),"\n",(0,s.jsxs)(i.table,{children:[(0,s.jsx)(i.thead,{children:(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.th,{children:"Parameter"}),(0,s.jsx)(i.th,{children:"Type"}),(0,s.jsx)(i.th,{children:"Description"})]})}),(0,s.jsx)(i.tbody,{children:(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:(0,s.jsx)(i.code,{children:"pos"})}),(0,s.jsx)(i.td,{children:(0,s.jsx)(i.code,{children:"Vector2Int"})}),(0,s.jsx)(i.td,{children:"Grid position to check"})]})})]}),"\n",(0,s.jsxs)(i.p,{children:[(0,s.jsx)(i.strong,{children:"Returns:"})," ",(0,s.jsx)(i.code,{children:"true"})," if position is valid, ",(0,s.jsx)(i.code,{children:"false"})," otherwise."]}),"\n",(0,s.jsx)(i.p,{children:(0,s.jsx)(i.strong,{children:"Example:"})}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-csharp",children:'var targetGrid = _pathfindingService.WorldToGridPosition(target.position);\r\n\r\nif (!_pathfindingService.IsValidGridPosition(targetGrid))\r\n{\r\n    Debug.LogWarning("Target is outside the pathfinding grid");\r\n    return;\r\n}\n'})}),"\n",(0,s.jsx)(i.hr,{}),"\n",(0,s.jsx)(i.h3,{id:"clamptovalidgridposition",children:"ClampToValidGridPosition"}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-csharp",children:"public Vector2Int ClampToValidGridPosition(Vector2Int pos)\n"})}),"\n",(0,s.jsx)(i.p,{children:"Clamps a grid position to valid bounds."}),"\n",(0,s.jsx)(i.p,{children:(0,s.jsx)(i.strong,{children:"Parameters:"})}),"\n",(0,s.jsxs)(i.table,{children:[(0,s.jsx)(i.thead,{children:(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.th,{children:"Parameter"}),(0,s.jsx)(i.th,{children:"Type"}),(0,s.jsx)(i.th,{children:"Description"})]})}),(0,s.jsx)(i.tbody,{children:(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:(0,s.jsx)(i.code,{children:"pos"})}),(0,s.jsx)(i.td,{children:(0,s.jsx)(i.code,{children:"Vector2Int"})}),(0,s.jsx)(i.td,{children:"Grid position to clamp"})]})})]}),"\n",(0,s.jsxs)(i.p,{children:[(0,s.jsx)(i.strong,{children:"Returns:"})," ",(0,s.jsx)(i.code,{children:"Vector2Int"})," clamped to valid grid bounds."]}),"\n",(0,s.jsx)(i.p,{children:(0,s.jsx)(i.strong,{children:"Example:"})}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-csharp",children:"var rawGridPos = new Vector2Int(100, -5);  // Potentially out of bounds\r\nvar validPos = _pathfindingService.ClampToValidGridPosition(rawGridPos);\n"})}),"\n",(0,s.jsx)(i.hr,{}),"\n",(0,s.jsx)(i.h3,{id:"getboundaryhandler",children:"GetBoundaryHandler"}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-csharp",children:"public GridBoundaryHandler GetBoundaryHandler()\n"})}),"\n",(0,s.jsx)(i.p,{children:"Gets the boundary handler for advanced operations."}),"\n",(0,s.jsxs)(i.p,{children:[(0,s.jsx)(i.strong,{children:"Returns:"})," ",(0,s.jsx)(i.code,{children:"GridBoundaryHandler"})," instance."]}),"\n",(0,s.jsx)(i.p,{children:(0,s.jsx)(i.strong,{children:"Example:"})}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-csharp",children:"var boundaryHandler = _pathfindingService.GetBoundaryHandler();\r\nDebug.Log(boundaryHandler.GetBoundaryInfo());\n"})}),"\n",(0,s.jsx)(i.h2,{id:"inspector-properties",children:"Inspector Properties"}),"\n",(0,s.jsx)(i.p,{children:"When added as a component, PathfindingService exposes:"}),"\n",(0,s.jsxs)(i.table,{children:[(0,s.jsx)(i.thead,{children:(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.th,{children:"Field"}),(0,s.jsx)(i.th,{children:"Default"}),(0,s.jsx)(i.th,{children:"Description"})]})}),(0,s.jsxs)(i.tbody,{children:[(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:(0,s.jsx)(i.strong,{children:"Auto Clamp Out Of Bounds"})}),(0,s.jsx)(i.td,{children:"true"}),(0,s.jsx)(i.td,{children:"Automatically clamp invalid positions to grid edges"})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:(0,s.jsx)(i.strong,{children:"Log Boundary Warnings"})}),(0,s.jsx)(i.td,{children:"false"}),(0,s.jsx)(i.td,{children:"Log warnings when positions are clamped"})]})]})]}),"\n",(0,s.jsx)(i.h2,{id:"performance-notes",children:"Performance Notes"}),"\n",(0,s.jsxs)(i.p,{children:[(0,s.jsx)(i.strong,{children:"Threading:"})," ",(0,s.jsx)(i.code,{children:"CalculatePath()"})," is synchronous but uses Unity's Job System internally. The A* algorithm runs as a Burst-compiled job on a worker thread, then completes before returning."]}),"\n",(0,s.jsxs)(i.p,{children:[(0,s.jsx)(i.strong,{children:"Blocking:"})," The method blocks the calling thread until the path is calculated. For very large grids, consider calling from a coroutine or limiting frequency."]}),"\n",(0,s.jsxs)(i.p,{children:[(0,s.jsx)(i.strong,{children:"Memory:"})," PathfindingService pre-allocates NativeArrays for pathfinding data. These are reused across calls to avoid GC allocation."]}),"\n",(0,s.jsx)(i.p,{children:(0,s.jsx)(i.strong,{children:"Typical Performance:"})}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{children:"[PathfindingService] Initialized with grid size 64x64, cell size: 15.625, flyCostMultiplier: 2.5\r\n[PathfindingService] Path found: 45 waypoints in 2ms\n"})}),"\n",(0,s.jsx)(i.h2,{id:"see-also",children:"See Also"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.a,{href:"../setup-guide/pathfinding-manager",children:"PathfindingManager"})," \u2014 High-level manager with mode support"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.a,{href:"./height-provider-interface",children:"IHeightProvider"})," \u2014 Height data interface"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.a,{href:"./grid-utilities",children:"GridBoundaryHandler"})," \u2014 Boundary handling utilities"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.a,{href:"./events",children:"Events"})," \u2014 Path calculation events"]}),"\n"]})]})}function h(e={}){const{wrapper:i}={...(0,d.R)(),...e.components};return i?(0,s.jsx)(i,{...e,children:(0,s.jsx)(a,{...e})}):a(e)}},8453:(e,i,n)=>{n.d(i,{R:()=>t,x:()=>o});var r=n(6540);const s={},d=r.createContext(s);function t(e){const i=r.useContext(d);return r.useMemo(function(){return"function"==typeof e?e(i):{...i,...e}},[i,e])}function o(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:t(e.components),r.createElement(d.Provider,{value:i},e.children)}}}]);