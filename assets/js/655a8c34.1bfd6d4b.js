"use strict";(globalThis.webpackChunkairpath_docs=globalThis.webpackChunkairpath_docs||[]).push([[9612],{5155:(e,i,t)=>{t.d(i,{A:()=>n});const n=t.p+"assets/images/diagonal-movement-70d731661150dc0ffd0ab198a2c15599.png"},5390:(e,i,t)=>{t.d(i,{A:()=>n});const n=t.p+"assets/images/algorithm-visualization-51d0ff1613f5fdb9da3b0511e6be9984.png"},8267:(e,i,t)=>{t.r(i),t.d(i,{assets:()=>a,contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>n,toc:()=>c});const n=JSON.parse('{"id":"core-concepts/pathfinding-algorithm","title":"Pathfinding Algorithm","description":"AirPath uses a height-aware A* algorithm optimized for aerial navigation. This page explains how the algorithm works and how it calculates path costs.","source":"@site/docs/core-concepts/pathfinding-algorithm.md","sourceDirName":"core-concepts","slug":"/core-concepts/pathfinding-algorithm","permalink":"/airpath-docs/docs/core-concepts/pathfinding-algorithm","draft":false,"unlisted":false,"editUrl":"https://github.com/maybebool/airpath-docs/tree/main/docs/core-concepts/pathfinding-algorithm.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4},"sidebar":"docsSidebar","previous":{"title":"Grid System","permalink":"/airpath-docs/docs/core-concepts/grid-system"},"next":{"title":"Configuration System","permalink":"/airpath-docs/docs/core-concepts/configuration-system"}}');var l=t(4848),s=t(8453);const r={sidebar_position:4},o="Pathfinding Algorithm",a={},c=[{value:"A* Overview",id:"a-overview",level:2},{value:"Height-Aware Cost Model",id:"height-aware-cost-model",level:2},{value:"Cost Formula",id:"cost-formula",level:3},{value:"Cost Components",id:"cost-components",level:3},{value:"1. Movement Cost (Distance)",id:"1-movement-cost-distance",level:4},{value:"2. Altitude Cost",id:"2-altitude-cost",level:4},{value:"3. Climb Cost",id:"3-climb-cost",level:4},{value:"4. Slope Penalty",id:"4-slope-penalty",level:4},{value:"Complete Example",id:"complete-example",level:3},{value:"Heuristic Function",id:"heuristic-function",level:2},{value:"Diagonal Movement",id:"diagonal-movement",level:2},{value:"FlyCostMultiplier",id:"flycostmultiplier",level:2},{value:"Performance Optimizations",id:"performance-optimizations",level:2},{value:"Burst Compilation",id:"burst-compilation",level:3},{value:"Memory Layout",id:"memory-layout",level:3},{value:"Algorithm Efficiency",id:"algorithm-efficiency",level:3},{value:"Path Result",id:"path-result",level:2},{value:"Walkability",id:"walkability",level:2},{value:"Algorithm Visualization",id:"algorithm-visualization",level:2},{value:"See Also",id:"see-also",level:2}];function d(e){const i={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...e.components};return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsx)(i.header,{children:(0,l.jsx)(i.h1,{id:"pathfinding-algorithm",children:"Pathfinding Algorithm"})}),"\n",(0,l.jsx)(i.p,{children:"AirPath uses a height-aware A* algorithm optimized for aerial navigation. This page explains how the algorithm works and how it calculates path costs."}),"\n",(0,l.jsx)(i.h2,{id:"a-overview",children:"A* Overview"}),"\n",(0,l.jsx)(i.p,{children:"A* is a best-first search algorithm that finds the shortest path between two points. It uses two values for each cell:"}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsxs)(i.li,{children:[(0,l.jsx)(i.strong,{children:"G Cost"})," \u2014 Actual cost to reach this cell from the start"]}),"\n",(0,l.jsxs)(i.li,{children:[(0,l.jsx)(i.strong,{children:"H Cost"})," \u2014 Estimated cost to reach the end (heuristic)"]}),"\n",(0,l.jsxs)(i.li,{children:[(0,l.jsx)(i.strong,{children:"F Cost"})," \u2014 Total cost (G + H)"]}),"\n"]}),"\n",(0,l.jsx)(i.p,{children:"The algorithm always explores the cell with the lowest F cost next, guaranteeing an optimal path."}),"\n",(0,l.jsx)(i.h2,{id:"height-aware-cost-model",children:"Height-Aware Cost Model"}),"\n",(0,l.jsx)(i.p,{children:"Standard A* only considers distance. AirPath adds height-based costs to create natural flight paths that prefer valleys over mountains."}),"\n",(0,l.jsx)(i.h3,{id:"cost-formula",children:"Cost Formula"}),"\n",(0,l.jsx)(i.pre,{children:(0,l.jsx)(i.code,{children:"Total G Cost = Previous G + Movement Cost + Fly Cost\r\n\r\nWhere Fly Cost = Altitude Cost + Climb Cost + Slope Penalty\n"})}),"\n",(0,l.jsx)(i.h3,{id:"cost-components",children:"Cost Components"}),"\n",(0,l.jsx)(i.h4,{id:"1-movement-cost-distance",children:"1. Movement Cost (Distance)"}),"\n",(0,l.jsx)(i.p,{children:"Base cost for moving between cells."}),"\n",(0,l.jsx)(i.pre,{children:(0,l.jsx)(i.code,{children:"Cardinal (N/S/E/W):  1.0 \xd7 CellSize\r\nDiagonal:           1.414 \xd7 CellSize  (\u221a2)\n"})}),"\n",(0,l.jsx)(i.h4,{id:"2-altitude-cost",children:"2. Altitude Cost"}),"\n",(0,l.jsx)(i.p,{children:"Penalizes being at high elevations. Makes paths prefer lower terrain."}),"\n",(0,l.jsx)(i.pre,{children:(0,l.jsx)(i.code,{children:"Altitude Cost = Height \xd7 FlyCostMultiplier \xd7 0.01\n"})}),"\n",(0,l.jsxs)(i.p,{children:[(0,l.jsx)(i.strong,{children:"Effect:"})," A cell at height 100 with multiplier 2.5 adds ",(0,l.jsx)(i.code,{children:"100 \xd7 2.5 \xd7 0.01 = 2.5"})," to the cost."]}),"\n",(0,l.jsx)(i.h4,{id:"3-climb-cost",children:"3. Climb Cost"}),"\n",(0,l.jsx)(i.p,{children:"Extra penalty for gaining altitude. Only applies when moving uphill."}),"\n",(0,l.jsx)(i.pre,{children:(0,l.jsx)(i.code,{children:"If going uphill (heightDiff > 0):\r\n    Climb Cost = HeightDifference \xd7 FlyCostMultiplier \xd7 0.5\r\n\r\nIf going downhill or level:\r\n    Climb Cost = 0\n"})}),"\n",(0,l.jsxs)(i.p,{children:[(0,l.jsx)(i.strong,{children:"Effect:"})," Climbing 10 units with multiplier 2.5 adds ",(0,l.jsx)(i.code,{children:"10 \xd7 2.5 \xd7 0.5 = 12.5"})," to the cost."]}),"\n",(0,l.jsx)(i.h4,{id:"4-slope-penalty",children:"4. Slope Penalty"}),"\n",(0,l.jsx)(i.p,{children:"Penalizes rapid height changes in either direction. Smooths paths and avoids cliff edges."}),"\n",(0,l.jsx)(i.pre,{children:(0,l.jsx)(i.code,{children:"Slope Penalty = |HeightDifference| \xd7 FlyCostMultiplier \xd7 0.1\n"})}),"\n",(0,l.jsxs)(i.p,{children:[(0,l.jsx)(i.strong,{children:"Effect:"})," A 10-unit height change (up or down) with multiplier 2.5 adds ",(0,l.jsx)(i.code,{children:"10 \xd7 2.5 \xd7 0.1 = 2.5"})," to the cost."]}),"\n",(0,l.jsx)(i.h3,{id:"complete-example",children:"Complete Example"}),"\n",(0,l.jsx)(i.p,{children:"Moving from a cell at height 50 to a neighbor at height 65 (cardinal direction):"}),"\n",(0,l.jsx)(i.pre,{children:(0,l.jsx)(i.code,{children:"Movement Cost:  1.0 \xd7 15.625 (cell size)     = 15.625\r\nAltitude Cost:  65 \xd7 2.5 \xd7 0.01              =  1.625\r\nClimb Cost:     15 \xd7 2.5 \xd7 0.5               = 18.75\r\nSlope Penalty:  15 \xd7 2.5 \xd7 0.1               =  3.75\r\n                                              \u2500\u2500\u2500\u2500\u2500\u2500\u2500\r\nTotal Cost:                                   39.75\n"})}),"\n",(0,l.jsx)(i.p,{children:"Compare to moving to a cell at height 50 (same level):"}),"\n",(0,l.jsx)(i.pre,{children:(0,l.jsx)(i.code,{children:"Movement Cost:  1.0 \xd7 15.625                 = 15.625\r\nAltitude Cost:  50 \xd7 2.5 \xd7 0.01              =  1.25\r\nClimb Cost:     0 (no climb)                 =  0\r\nSlope Penalty:  0 (no height change)         =  0\r\n                                              \u2500\u2500\u2500\u2500\u2500\u2500\u2500\r\nTotal Cost:                                   16.875\n"})}),"\n",(0,l.jsx)(i.p,{children:"The algorithm strongly prefers the level path."}),"\n",(0,l.jsx)(i.h2,{id:"heuristic-function",children:"Heuristic Function"}),"\n",(0,l.jsxs)(i.p,{children:["AirPath uses ",(0,l.jsx)(i.strong,{children:"Octile distance"})," \u2014 the optimal heuristic for 8-directional movement:"]}),"\n",(0,l.jsx)(i.pre,{children:(0,l.jsx)(i.code,{children:"Octile Distance = max(dx, dy) + 0.414 \xd7 min(dx, dy)\n"})}),"\n",(0,l.jsxs)(i.p,{children:["Where ",(0,l.jsx)(i.code,{children:"dx"})," and ",(0,l.jsx)(i.code,{children:"dy"})," are the grid distances to the target."]}),"\n",(0,l.jsx)(i.p,{children:"This heuristic is:"}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsxs)(i.li,{children:[(0,l.jsx)(i.strong,{children:"Admissible"})," \u2014 Never overestimates, guaranteeing optimal paths"]}),"\n",(0,l.jsxs)(i.li,{children:[(0,l.jsx)(i.strong,{children:"Consistent"})," \u2014 Ensures efficient search without revisiting nodes"]}),"\n"]}),"\n",(0,l.jsx)(i.h2,{id:"diagonal-movement",children:"Diagonal Movement"}),"\n",(0,l.jsx)(i.p,{children:"The algorithm supports 8-directional movement with corner-cutting prevention:"}),"\n",(0,l.jsx)("img",{src:t(5155).A,alt:"How AirPath Works - Architecture Overview",width:"500"}),"\n",(0,l.jsx)(i.p,{children:"A diagonal move is only allowed if at least one adjacent cardinal cell is walkable."}),"\n",(0,l.jsx)(i.h2,{id:"flycostmultiplier",children:"FlyCostMultiplier"}),"\n",(0,l.jsxs)(i.p,{children:["The ",(0,l.jsx)(i.strong,{children:"Fly Cost Multiplier"})," in ",(0,l.jsx)(i.code,{children:"PathfindingConfiguration"})," scales all height-based costs:"]}),"\n",(0,l.jsxs)(i.table,{children:[(0,l.jsx)(i.thead,{children:(0,l.jsxs)(i.tr,{children:[(0,l.jsx)(i.th,{children:"Value"}),(0,l.jsx)(i.th,{children:"Effect"})]})}),(0,l.jsxs)(i.tbody,{children:[(0,l.jsxs)(i.tr,{children:[(0,l.jsx)(i.td,{children:"0.5"}),(0,l.jsx)(i.td,{children:"Weak height avoidance \u2014 paths may cross mountains"})]}),(0,l.jsxs)(i.tr,{children:[(0,l.jsx)(i.td,{children:"2.5"}),(0,l.jsx)(i.td,{children:"Default \u2014 balanced height consideration"})]}),(0,l.jsxs)(i.tr,{children:[(0,l.jsx)(i.td,{children:"5.0"}),(0,l.jsx)(i.td,{children:"Strong height avoidance \u2014 paths strongly prefer valleys"})]}),(0,l.jsxs)(i.tr,{children:[(0,l.jsx)(i.td,{children:"10.0"}),(0,l.jsx)(i.td,{children:"Very strong \u2014 almost always takes lowest route"})]})]})]}),"\n",(0,l.jsxs)(i.p,{children:[(0,l.jsx)(i.strong,{children:"Tuning tip:"})," Increase if paths cross terrain you'd expect them to avoid. Decrease if paths take unnecessarily long detours."]}),"\n",(0,l.jsx)(i.h2,{id:"performance-optimizations",children:"Performance Optimizations"}),"\n",(0,l.jsx)(i.p,{children:"The A* job is heavily optimized:"}),"\n",(0,l.jsx)(i.h3,{id:"burst-compilation",children:"Burst Compilation"}),"\n",(0,l.jsx)(i.pre,{children:(0,l.jsx)(i.code,{className:"language-csharp",children:"[BurstCompile(\r\n    FloatMode = FloatMode.Fast,\r\n    FloatPrecision = FloatPrecision.Standard,\r\n    OptimizeFor = OptimizeFor.Performance\r\n)]\n"})}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsx)(i.li,{children:"Compiles to native code"}),"\n",(0,l.jsx)(i.li,{children:"SIMD vectorization where possible"}),"\n",(0,l.jsx)(i.li,{children:"No garbage collection"}),"\n"]}),"\n",(0,l.jsx)(i.h3,{id:"memory-layout",children:"Memory Layout"}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsxs)(i.li,{children:["Flat arrays indexed by ",(0,l.jsx)(i.code,{children:"y \xd7 width + x"})]}),"\n",(0,l.jsx)(i.li,{children:"Cache-friendly access patterns"}),"\n",(0,l.jsx)(i.li,{children:"Pre-allocated NativeArrays (no allocation during pathfinding)"}),"\n"]}),"\n",(0,l.jsx)(i.h3,{id:"algorithm-efficiency",children:"Algorithm Efficiency"}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsx)(i.li,{children:"Early exit when destination reached"}),"\n",(0,l.jsx)(i.li,{children:"Processed nodes never revisited"}),"\n",(0,l.jsx)(i.li,{children:"Maximum iteration limit prevents infinite loops"}),"\n"]}),"\n",(0,l.jsx)(i.h2,{id:"path-result",children:"Path Result"}),"\n",(0,l.jsxs)(i.p,{children:["The algorithm returns grid indices, which ",(0,l.jsx)(i.code,{children:"PathfindingService"})," converts to world positions:"]}),"\n",(0,l.jsx)(i.pre,{children:(0,l.jsx)(i.code,{children:"Grid Path:    [0] \u2192 [15] \u2192 [30] \u2192 [45] \u2192 [60]\r\n                     \u2193\r\nWorld Path:   [(10, 5, 20), (25, 8, 35), (40, 12, 50), ...]\n"})}),"\n",(0,l.jsx)(i.p,{children:"Each world position includes:"}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsx)(i.li,{children:"X/Z from grid cell center"}),"\n",(0,l.jsx)(i.li,{children:"Y from terrain height + height offset"}),"\n"]}),"\n",(0,l.jsx)(i.h2,{id:"walkability",children:"Walkability"}),"\n",(0,l.jsxs)(i.p,{children:["All cells are walkable by default. The system checks ",(0,l.jsx)(i.code,{children:"IsWalkable"})," but currently doesn't provide a way to mark cells as blocked. Future versions may add obstacle support."]}),"\n",(0,l.jsx)(i.h2,{id:"algorithm-visualization",children:"Algorithm Visualization"}),"\n",(0,l.jsx)("img",{src:t(5390).A,alt:"How AirPath Works - Architecture Overview",width:"600"}),"\n",(0,l.jsx)(i.h2,{id:"see-also",children:"See Also"}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsxs)(i.li,{children:[(0,l.jsx)(i.a,{href:"./grid-system",children:"Grid System"})," \u2014 How the pathfinding grid works"]}),"\n",(0,l.jsxs)(i.li,{children:[(0,l.jsx)(i.a,{href:"../api-reference/pathfinding-service",children:"PathfindingService"})," \u2014 API for path calculation"]}),"\n",(0,l.jsxs)(i.li,{children:[(0,l.jsx)(i.a,{href:"../advanced/performance-tuning",children:"Performance Tuning"})," \u2014 Optimizing pathfinding"]}),"\n"]})]})}function h(e={}){const{wrapper:i}={...(0,s.R)(),...e.components};return i?(0,l.jsx)(i,{...e,children:(0,l.jsx)(d,{...e})}):d(e)}},8453:(e,i,t)=>{t.d(i,{R:()=>r,x:()=>o});var n=t(6540);const l={},s=n.createContext(l);function r(e){const i=n.useContext(s);return n.useMemo(function(){return"function"==typeof e?e(i):{...i,...e}},[i,e])}function o(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(l):e.components||l:r(e.components),n.createElement(s.Provider,{value:i},e.children)}}}]);