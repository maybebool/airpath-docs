"use strict";(globalThis.webpackChunkairpath_docs=globalThis.webpackChunkairpath_docs||[]).push([[3482],{497:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>d,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"advanced/pathfinding-modes","title":"Pathfinding Modes","description":"AirPath supports different pathfinding modes that determine how start and end positions are selected. This page explains the built-in modes and how to create custom ones.","source":"@site/docs/advanced/pathfinding-modes.md","sourceDirName":"advanced","slug":"/advanced/pathfinding-modes","permalink":"/airpath-docs/docs/advanced/pathfinding-modes","draft":false,"unlisted":false,"editUrl":"https://github.com/maybebool/airpath-docs/tree/main/docs/advanced/pathfinding-modes.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"docsSidebar","previous":{"title":"Performance Tuning","permalink":"/airpath-docs/docs/advanced/performance-tuning"},"next":{"title":"Swarm Integration","permalink":"/airpath-docs/docs/advanced/swarm-integration"}}');var t=i(4848),s=i(8453);const a={sidebar_position:2},o="Pathfinding Modes",d={},l=[{value:"Overview",id:"overview",level:2},{value:"Built-in Modes",id:"built-in-modes",level:2},{value:"MouseClick Mode",id:"mouseclick-mode",level:3},{value:"TargetFollow Mode",id:"targetfollow-mode",level:3},{value:"Switching Modes",id:"switching-modes",level:2},{value:"In the Inspector",id:"in-the-inspector",level:3},{value:"At Runtime",id:"at-runtime",level:3},{value:"Mode Changed Event",id:"mode-changed-event",level:3},{value:"Mode Comparison",id:"mode-comparison",level:2},{value:"Creating Custom Modes",id:"creating-custom-modes",level:2},{value:"Step 1: Create the Mode Class",id:"step-1-create-the-mode-class",level:3},{value:"Step 2: Integrate with PathfindingManager",id:"step-2-integrate-with-pathfindingmanager",level:3},{value:"Custom Mode Ideas",id:"custom-mode-ideas",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"Choosing a Mode",id:"choosing-a-mode",level:3},{value:"Performance Considerations",id:"performance-considerations",level:3},{value:"Visual Debugging",id:"visual-debugging",level:3},{value:"See Also",id:"see-also",level:2}];function c(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"pathfinding-modes",children:"Pathfinding Modes"})}),"\n",(0,t.jsx)(n.p,{children:"AirPath supports different pathfinding modes that determine how start and end positions are selected. This page explains the built-in modes and how to create custom ones."}),"\n",(0,t.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,t.jsx)(n.p,{children:"Pathfinding modes control:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["How the ",(0,t.jsx)(n.strong,{children:"start position"})," is determined"]}),"\n",(0,t.jsxs)(n.li,{children:["How the ",(0,t.jsx)(n.strong,{children:"end position"})," is determined"]}),"\n",(0,t.jsxs)(n.li,{children:["When ",(0,t.jsx)(n.strong,{children:"recalculation"})," occurs"]}),"\n",(0,t.jsxs)(n.li,{children:["What ",(0,t.jsx)(n.strong,{children:"visual feedback"})," is shown"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"built-in-modes",children:"Built-in Modes"}),"\n",(0,t.jsx)(n.h3,{id:"mouseclick-mode",children:"MouseClick Mode"}),"\n",(0,t.jsx)(n.p,{children:"Click to set start and end positions manually. Ideal for testing and debugging."}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"How it works:"})}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["First click sets the ",(0,t.jsx)(n.strong,{children:"start position"})," (green cylinder marker)"]}),"\n",(0,t.jsxs)(n.li,{children:["Second click sets the ",(0,t.jsx)(n.strong,{children:"end position"})," (red cylinder marker)"]}),"\n",(0,t.jsx)(n.li,{children:"Path is calculated immediately"}),"\n",(0,t.jsx)(n.li,{children:"Click again to set a new start position"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Visual indicators:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Green cylinder at start position"}),"\n",(0,t.jsx)(n.li,{children:"Red cylinder at end position"}),"\n",(0,t.jsx)(n.li,{children:"Path line connecting them (if visualization enabled)"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Use cases:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Testing pathfinding during development"}),"\n",(0,t.jsx)(n.li,{children:"Debugging path quality"}),"\n",(0,t.jsx)(n.li,{children:"Demos and presentations"}),"\n",(0,t.jsx)(n.li,{children:"Player-controlled navigation"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"targetfollow-mode",children:"TargetFollow Mode"}),"\n",(0,t.jsx)(n.p,{children:"Continuously tracks a moving target. Ideal for AI agents following players or waypoints."}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"How it works:"})}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["Assigns a ",(0,t.jsx)(n.strong,{children:"Target To Follow"})," transform"]}),"\n",(0,t.jsx)(n.li,{children:"Uses swarm position (or PathfindingManager position) as start"}),"\n",(0,t.jsx)(n.li,{children:"Continuously recalculates path as target moves"}),"\n",(0,t.jsx)(n.li,{children:"Smart throttling prevents excessive recalculation"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Visual indicators:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Yellow sphere at current target position"}),"\n",(0,t.jsx)(n.li,{children:"Boundary warning when target leaves grid"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Configuration options:"})}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Setting"}),(0,t.jsx)(n.th,{children:"Description"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Target To Follow"}),(0,t.jsx)(n.td,{children:"The transform to track"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Min Recalculation Interval"}),(0,t.jsx)(n.td,{children:"Minimum time between path updates"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Target Move Threshold"}),(0,t.jsx)(n.td,{children:"Grid cells target must move to trigger recalc"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Swarm Move Threshold"}),(0,t.jsx)(n.td,{children:"Grid cells swarm must move to trigger recalc"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Use Distance Based Throttling"}),(0,t.jsx)(n.td,{children:"Reduce update frequency for distant targets"})]})]})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Use cases:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"AI following the player"}),"\n",(0,t.jsx)(n.li,{children:"Enemies tracking targets"}),"\n",(0,t.jsx)(n.li,{children:"NPCs moving to waypoints"}),"\n",(0,t.jsx)(n.li,{children:"Flocking/swarm behavior"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"switching-modes",children:"Switching Modes"}),"\n",(0,t.jsx)(n.h3,{id:"in-the-inspector",children:"In the Inspector"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["Select the GameObject with ",(0,t.jsx)(n.code,{children:"PathfindingManager"})]}),"\n",(0,t.jsxs)(n.li,{children:["Change ",(0,t.jsx)(n.strong,{children:"Starting Mode"})," dropdown"]}),"\n",(0,t.jsx)(n.li,{children:"Configure mode-specific settings"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"at-runtime",children:"At Runtime"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"// Get reference to PathfindingManager\r\nPathfindingManager manager = GetComponent<PathfindingManager>();\r\n\r\n// Switch to MouseClick mode\r\nmanager.SetMode(PathfindingModeType.MouseClick);\r\n\r\n// Switch to TargetFollow mode\r\nmanager.SetMode(PathfindingModeType.TargetFollow);\n"})}),"\n",(0,t.jsx)(n.h3,{id:"mode-changed-event",children:"Mode Changed Event"}),"\n",(0,t.jsx)(n.p,{children:"Subscribe to know when modes change:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'this.Subscribe<PathfindingModeChangedEvent>(evt =>\r\n{\r\n    Debug.Log($"Mode changed from {evt.PreviousMode} to {evt.NewMode}");\r\n    \r\n    // Access the new mode instance if needed\r\n    var modeInstance = evt.ModeInstance;\r\n});\n'})}),"\n",(0,t.jsx)(n.h2,{id:"mode-comparison",children:"Mode Comparison"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Feature"}),(0,t.jsx)(n.th,{children:"MouseClick"}),(0,t.jsx)(n.th,{children:"TargetFollow"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Start Position"}),(0,t.jsx)(n.td,{children:"Click to set"}),(0,t.jsx)(n.td,{children:"Swarm/Manager position"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"End Position"}),(0,t.jsx)(n.td,{children:"Click to set"}),(0,t.jsx)(n.td,{children:"Target transform"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Recalculation"}),(0,t.jsx)(n.td,{children:"Manual (on click)"}),(0,t.jsx)(n.td,{children:"Automatic (continuous)"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Best For"}),(0,t.jsx)(n.td,{children:"Testing, manual control"}),(0,t.jsx)(n.td,{children:"AI, automatic tracking"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Visual Markers"}),(0,t.jsx)(n.td,{children:"Green/Red cylinders"}),(0,t.jsx)(n.td,{children:"Yellow sphere"})]})]})]}),"\n",(0,t.jsx)(n.h2,{id:"creating-custom-modes",children:"Creating Custom Modes"}),"\n",(0,t.jsx)(n.p,{children:"You can create custom pathfinding modes by implementing the mode interface pattern."}),"\n",(0,t.jsx)(n.h3,{id:"step-1-create-the-mode-class",children:"Step 1: Create the Mode Class"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"using UnityEngine;\r\nusing PlatypusIdeas.AirPath.Runtime.Core.Pathfinding;\r\n\r\npublic class WaypointPathfindingMode : MonoBehaviour\r\n{\r\n    [SerializeField] private Transform[] waypoints;\r\n    [SerializeField] private float arrivalDistance = 2f;\r\n    \r\n    private PathfindingManager manager;\r\n    private int currentWaypointIndex = 0;\r\n    \r\n    public void Initialize(PathfindingManager pathfindingManager)\r\n    {\r\n        manager = pathfindingManager;\r\n        RequestPathToNextWaypoint();\r\n    }\r\n    \r\n    public void UpdateMode()\r\n    {\r\n        // Check if we've reached the current waypoint\r\n        if (HasReachedCurrentWaypoint())\r\n        {\r\n            currentWaypointIndex++;\r\n            \r\n            if (currentWaypointIndex < waypoints.Length)\r\n            {\r\n                RequestPathToNextWaypoint();\r\n            }\r\n        }\r\n    }\r\n    \r\n    private void RequestPathToNextWaypoint()\r\n    {\r\n        if (waypoints == null || waypoints.Length == 0)\r\n            return;\r\n            \r\n        var start = manager.transform.position;\r\n        var end = waypoints[currentWaypointIndex].position;\r\n        \r\n        // Request path calculation\r\n        manager.RequestPath(start, end);\r\n    }\r\n    \r\n    private bool HasReachedCurrentWaypoint()\r\n    {\r\n        if (currentWaypointIndex >= waypoints.Length)\r\n            return false;\r\n            \r\n        var distance = Vector3.Distance(\r\n            manager.transform.position,\r\n            waypoints[currentWaypointIndex].position\r\n        );\r\n        \r\n        return distance < arrivalDistance;\r\n    }\r\n    \r\n    public void Cleanup()\r\n    {\r\n        // Clean up any resources\r\n    }\r\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"step-2-integrate-with-pathfindingmanager",children:"Step 2: Integrate with PathfindingManager"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"// Add your custom mode component\r\nvar waypointMode = gameObject.AddComponent<WaypointPathfindingMode>();\r\n\r\n// Initialize it\r\nwaypointMode.Initialize(pathfindingManager);\r\n\r\n// Call UpdateMode in your game loop\r\nvoid Update()\r\n{\r\n    waypointMode.UpdateMode();\r\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"custom-mode-ideas",children:"Custom Mode Ideas"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Patrol Mode"})," \u2014 Cycle through waypoints continuously"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"// When reaching last waypoint, loop back to first\r\nif (currentWaypointIndex >= waypoints.Length)\r\n{\r\n    currentWaypointIndex = 0;\r\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Flee Mode"})," \u2014 Move away from a threat"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"// Calculate position opposite to threat\r\nvar fleeDirection = (transform.position - threat.position).normalized;\r\nvar fleeTarget = transform.position + fleeDirection * fleeDistance;\r\nmanager.RequestPath(transform.position, fleeTarget);\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Random Wander Mode"})," \u2014 Pick random destinations"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"// Pick random point within bounds\r\nvar randomPoint = new Vector3(\r\n    Random.Range(minBounds.x, maxBounds.x),\r\n    0,\r\n    Random.Range(minBounds.z, maxBounds.z)\r\n);\r\nmanager.RequestPath(transform.position, randomPoint);\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Formation Mode"})," \u2014 Maintain position relative to leader"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"// Calculate offset position from leader\r\nvar formationTarget = leader.position + formationOffset;\r\nmanager.RequestPath(transform.position, formationTarget);\n"})}),"\n",(0,t.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,t.jsx)(n.h3,{id:"choosing-a-mode",children:"Choosing a Mode"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Use ",(0,t.jsx)(n.strong,{children:"MouseClick"})," during development for testing"]}),"\n",(0,t.jsxs)(n.li,{children:["Use ",(0,t.jsx)(n.strong,{children:"TargetFollow"})," for production AI behavior"]}),"\n",(0,t.jsxs)(n.li,{children:["Create ",(0,t.jsx)(n.strong,{children:"custom modes"})," for specific gameplay needs"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"performance-considerations",children:"Performance Considerations"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"MouseClick"})," has minimal overhead (only calculates on click)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"TargetFollow"})," needs throttling tuning for many agents"]}),"\n",(0,t.jsx)(n.li,{children:"Custom modes should implement smart recalculation logic"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"visual-debugging",children:"Visual Debugging"}),"\n",(0,t.jsx)(n.p,{children:"Both built-in modes create visual markers. Disable these in production:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"// Markers are created as child objects\r\n// Disable or destroy them when not needed\n"})}),"\n",(0,t.jsx)(n.h2,{id:"see-also",children:"See Also"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"../setup-guide/pathfinding-manager",children:"Pathfinding Manager"})," \u2014 Manager setup and configuration"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"../api-reference/events",children:"Events"})," \u2014 PathfindingModeChangedEvent details"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"./performance-tuning",children:"Performance Tuning"})," \u2014 Throttling configuration"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>a,x:()=>o});var r=i(6540);const t={},s=r.createContext(t);function a(e){const n=r.useContext(s);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),r.createElement(s.Provider,{value:n},e.children)}}}]);